load("@build_bazel_rules_nodejs//:providers.bzl", "DeclarationInfo", "JSEcmaScriptModuleInfo", "JSNamedModuleInfo")
load("@rules_proto//proto:defs.bzl", "ProtoInfo")

TypescriptProtoLibraryAspect = provider(
    fields = {
        "es5_outputs": "The ES5 JS files produced directly from the src protos",
        "es6_outputs": "The ES6 JS files produced directly from the src protos",
        "dts_outputs": "Ths TS definition files produced directly from the src protos",
        "deps_es5": "The transitive ES5 JS dependencies",
        "deps_es6": "The transitive ES6 JS dependencies",
        "deps_dts": "The transitive dependencies' TS definitions",
    },
)

def _proto_path(proto):
    """
    The proto path is not really a file path. It's the path to the proto that was seen when the
    descriptor file was generated. It takes into account any stripped or added prefixes part of the
    declaring proto_library rule.
    """
    path = proto.path
    root = proto.root.path
    ws = proto.owner.workspace_root
    virt_prefix = "_virtual_imports/" + proto.owner.name
    if proto.owner.package:
        virt_prefix = proto.owner.package + "/" + virt_prefix

    if path.startswith(root):
        path = path[len(root):].strip("/")
    if path.startswith(ws):
        path = path[len(ws):].strip("/")
    if path.startswith(virt_prefix):
        path = path[len(virt_prefix):].strip("/")
    return path

def _get_protoc_inputs(target, ctx):
    inputs = []
    inputs += target[ProtoInfo].direct_sources
    inputs += target[ProtoInfo].transitive_descriptor_sets.to_list()
    return inputs

def _get_input_proto_names(target):
    """
    Builds a string containing all of the input proto file names separated by spaces.
    """
    proto_inputs = []
    for src in target[ProtoInfo].direct_sources:
        if src.extension != "proto":
            fail("Input must be a proto file")
        normalized_file = _proto_path(src)
        proto_inputs.append(normalized_file)
    return " ".join(proto_inputs)

def _build_output_dir_command(target, ctx):
    """
    Output for JS & TS generation should stored into a specifically created directory within the
    current package's binary directory. The directory is named after the generating rule (usually
    'native_proto_library%').
    """
    output_path_elems = [
        ctx.var["BINDIR"].rstrip("/"),
    ]
    if ctx.label.workspace_root != "__main__":
        output_path_elems = output_path_elems + [
            ctx.label.workspace_root,
        ]
    output_path_elems = output_path_elems + [
        ctx.label.package,
        ctx.label.name + "%",
    ]
    output_path = "/".join([p for p in output_path_elems if p])

    mkdir_cmd = 'mkdir -p "%s"'%(output_path)
    output_dir = ctx.actions.declare_directory(ctx.label.name + "%")
    return output_dir, mkdir_cmd

def _build_protoc_command(target, output_dir, ctx):
    protoc_command = "%s" % (ctx.file._protoc.path)

    protoc_command += " --plugin=protoc-gen-ts=%s" % (ctx.files._ts_protoc_gen[1].path)

    protoc_command += " --ts_out=service=grpc-web:%s" % (output_dir.path)
    protoc_command += " --js_out=import_style=commonjs,binary:%s" % (output_dir.path)

    descriptor_sets_paths = [desc.path for desc in target[ProtoInfo].transitive_descriptor_sets.to_list()]
    protoc_command += " --descriptor_set_in=%s" % (":".join(descriptor_sets_paths))

    protoc_command += " %s" % (_get_input_proto_names(target))

    return protoc_command

def _create_post_process_command(target, ctx, js_outputs, js_outputs_es6):
    """
    Builds a post-processing command that:
      - Updates the existing protoc output files to be UMD modules
      - Creates a new es6 file from the original protoc output
    """
    convert_commands = []
    for [output, output_es6] in zip(js_outputs, js_outputs_es6):
        file_name = output.basename[:-len(output.extension) - 1]

        convert_command = ctx.files._change_import_style[1].path
        convert_command += " --workspace_name {}".format(ctx.workspace_name.replace("__main__", ""))
        convert_command += " --input_base_path {}".format(ctx.label.package)
        convert_command += " --output_module_name {}".format(file_name)
        convert_command += " --input_file_path {}".format(output.path)
        convert_command += " --output_umd_path {}".format(output.path)
        convert_command += " --output_es6_path {}".format(output_es6.path)
        convert_commands.append(convert_command)

    return " && ".join(convert_commands)

def _get_outputs(target, ctx):
    """
    Calculates all of the files that will be generated by the aspect.
    """
    js_outputs = []
    js_outputs_es6 = []
    dts_outputs = []
    for src in target[ProtoInfo].direct_sources:
        base_path = "/".join([p for p in [
            ctx.label.name + "%",
            _proto_path(src)[:-len(src.basename)-1],
            src.basename[:-len(src.extension) - 1],
        ] if p])

        for f in ["_pb", "_pb_service"]:
            full_path = base_path + f
            output = ctx.actions.declare_file(full_path + ".js")
            js_outputs.append(output)
            output_es6 = ctx.actions.declare_file(full_path + ".mjs")
            js_outputs_es6.append(output_es6)

        for f in ["_pb.d.ts", "_pb_service.d.ts"]:
            full_path = base_path + f
            output = ctx.actions.declare_file(full_path)
            dts_outputs.append(output)

    return [js_outputs, js_outputs_es6, dts_outputs]

def typescript_proto_library_aspect_(target, ctx):
    """
    A bazel aspect that is applied on every proto_library rule on the transitive set of dependencies
    of a typescript_proto_library rule.

    Handles running protoc to produce the generated JS and TS files.
    """

    output_dir, mk_output_dir_cmd = _build_output_dir_command(target, ctx)

    [js_outputs, js_outputs_es6, dts_outputs] = _get_outputs(target, ctx)
    protoc_outputs = [output_dir] + dts_outputs + js_outputs + js_outputs_es6

    all_commands = [
        mk_output_dir_cmd,
        _build_protoc_command(target, output_dir, ctx),
        _create_post_process_command(target, ctx, js_outputs, js_outputs_es6),
    ]

    tools = []
    tools.extend(ctx.files._protoc)
    tools.extend(ctx.files._ts_protoc_gen)
    tools.extend(ctx.files._change_import_style)

    ctx.actions.run_shell(
        inputs = depset(_get_protoc_inputs(target, ctx)),
        outputs = protoc_outputs,
        progress_message = "Creating Typescript pb files %s" % ctx.label,
        command = " && ".join(all_commands),
        tools = depset(tools),
    )

    dts_outputs = depset(dts_outputs)
    es5_outputs = depset(js_outputs)
    es6_outputs = depset(js_outputs_es6)
    deps_dts = []
    deps_es5 = []
    deps_es6 = []

    for dep in ctx.rule.attr.deps:
        aspect_data = dep[TypescriptProtoLibraryAspect]
        deps_dts.append(aspect_data.dts_outputs)
        deps_dts.append(aspect_data.deps_dts)
        deps_es5.append(aspect_data.es5_outputs)
        deps_es5.append(aspect_data.deps_es5)
        deps_es6.append(aspect_data.es6_outputs)
        deps_es6.append(aspect_data.deps_es6)

    return [TypescriptProtoLibraryAspect(
        dts_outputs = dts_outputs,
        es5_outputs = es5_outputs,
        es6_outputs = es6_outputs,
        deps_dts = depset(transitive = deps_dts),
        deps_es5 = depset(transitive = deps_es5),
        deps_es6 = depset(transitive = deps_es6),
    )]

typescript_proto_library_aspect = aspect(
    attr_aspects = ["deps"],
    attrs = {
        "_ts_protoc_gen": attr.label(
            allow_files = True,
            executable = True,
            cfg = "host",
            default = Label("@rules_typescript_proto_deps//ts-protoc-gen/bin:protoc-gen-ts"),
        ),
        "_protoc": attr.label(
            allow_single_file = True,
            executable = True,
            cfg = "host",
            default = Label("@com_google_protobuf//:protoc"),
        ),
        "_change_import_style": attr.label(
            executable = True,
            cfg = "host",
            allow_files = True,
            default = Label("//src:change_import_style"),
        ),
    },
    implementation = typescript_proto_library_aspect_,
)

def _typescript_proto_library_impl(ctx):
    """
    Handles converting the aspect output into a provider compatible with the rules_typescript rules.
    """
    aspect_data = ctx.attr.proto[TypescriptProtoLibraryAspect]
    dts_outputs = aspect_data.dts_outputs
    transitive_declarations = depset(transitive = [dts_outputs, aspect_data.deps_dts])
    es5_outputs = aspect_data.es5_outputs
    es6_outputs = aspect_data.es6_outputs
    outputs = depset(transitive = [es5_outputs, es6_outputs, dts_outputs])

    es5_srcs = depset(transitive = [es5_outputs, aspect_data.deps_es5])
    es6_srcs = depset(transitive = [es6_outputs, aspect_data.deps_es6])
    return struct(
        typescript = struct(
            declarations = dts_outputs,
            transitive_declarations = transitive_declarations,
            type_blacklisted_declarations = depset([]),
            es5_sources = es5_srcs,
            es6_sources = es6_srcs,
            transitive_es5_sources = es5_srcs,
            transitive_es6_sources = es6_srcs,
        ),
        providers = [
            DefaultInfo(files = outputs),
            DeclarationInfo(
                declarations = dts_outputs,
                transitive_declarations = transitive_declarations,
            ),
            JSNamedModuleInfo(
                direct_sources = es5_srcs,
                sources = es5_srcs,
            ),
            JSEcmaScriptModuleInfo(
                direct_sources = es6_srcs,
                sources = es6_srcs,
            ),
        ],
    )

typescript_proto_library = rule(
    attrs = {
        "proto": attr.label(
            mandatory = True,
            allow_single_file = True,
            providers = [ProtoInfo],
            aspects = [typescript_proto_library_aspect],
        ),
        "_ts_protoc_gen": attr.label(
            allow_files = True,
            executable = True,
            cfg = "host",
            default = Label("@rules_typescript_proto_deps//ts-protoc-gen/bin:protoc-gen-ts"),
        ),
        "_protoc": attr.label(
            allow_single_file = True,
            executable = True,
            cfg = "host",
            default = Label("@com_google_protobuf//:protoc"),
        ),
    },
    implementation = _typescript_proto_library_impl,
)
